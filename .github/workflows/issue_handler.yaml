name: Network Access Issue Handler

on:
  issues:
    types: 
      - opened
      - edited

jobs:
  process_access_request:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'


      - name: Extract and Validate Issue YAML
        id: validate_yaml
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Start Fraiche
          rm -f /tmp/issue.yaml /tmp/thirdparty_validator.yaml xx*
          set -x
          set +e
          
          pip install --quiet yamllint jsonschema PyYaml

          # Extract YAML from codefence
          jq -r '.issue.body' "$GITHUB_EVENT_PATH" | awk '/^```yaml/{flag=1; next} /^```/{flag=0} flag' > /tmp/issue.yaml

          echo "DEBUG: Printing first few lines of /tmp/issue.yaml"
          head -20 /tmp/issue.yaml || true
          echo "DEBUG: Checking schema directory"
          ls -lh .github/schemas || true

          # -------- Yamllint --------
          yamllint --format standard -c .yamllint /tmp/issue.yaml > /tmp/yamllint_output.txt 2>&1
          YAMLLINT_OK=$?
          echo "DEBUG: yamllint exit code: $YAMLLINT_OK"

          SCHEMA_OK=1 # Default to error unless proven valid

          if [ $YAMLLINT_OK -eq 0 ]; then
            # Only try schema validation if YAML is valid
            SERVICE_TYPE=$(yq '.security_group.serviceType' /tmp/issue.yaml | tr -d '"')
            if [[ -z "$SERVICE_TYPE" || "$SERVICE_TYPE" == "null" ]]; then
              SERVICE_TYPE=$(jq -r '.issue.labels[].name' "$GITHUB_EVENT_PATH" | grep -E 'privatelink-(consumer|provider)' | head -1)
              echo "DEBUG: Falling back to label for service type: '$SERVICE_TYPE'"
            fi

            echo "DEBUG: Detected serviceType: '$SERVICE_TYPE'"

            if [ "$SERVICE_TYPE" = "privatelink-consumer" ] || [ "$SERVICE_TYPE" = "privatelink-provider" ]; then
              SCHEMA_PATH=".github/schemas/${SERVICE_TYPE}-schema.json"
              echo "DEBUG: Using schema path: $SCHEMA_PATH"
              python3 ./scripts/validate_schema.py /tmp/issue.yaml "$SCHEMA_PATH" > /tmp/schema_output.txt 2>&1
              SCHEMA_OK=$?
            else
              echo "‚ùå Error: serviceType is missing or invalid: '$SERVICE_TYPE'" | tee /tmp/schema_output.txt
              SCHEMA_OK=1
            fi
          else
            echo "Skipping schema validation due to YAML lint failure." > /tmp/schema_output.txt
          fi

          # -------- Always Show Outputs --------
          echo "-------------------------"
          echo "YAMLLINT OUTPUT:"
          cat /tmp/yamllint_output.txt
          echo "-------------------------"
          echo "SCHEMA VALIDATION OUTPUT:"
          cat /tmp/schema_output.txt
          echo "-------------------------"

          # -------- Compose Comment if needed --------
          if [ $YAMLLINT_OK -ne 0 ] || [ $SCHEMA_OK -ne 0 ]; then
            {
              echo "### ‚ö†Ô∏è Validation Results"
              echo ""
              if [ $YAMLLINT_OK -ne 0 ]; then
                echo "#### Fix YAML Formatting Errors:"
                echo '```yaml'
                cat /tmp/yamllint_output.txt
                echo '```'
                echo ""
              else
                echo "#### ‚úÖ YAML Format Validation: Passed"
                echo ""
              fi
              if [ $SCHEMA_OK -ne 0 ]; then
                echo "#### Schema Validation Issues:"
                echo '```'
                cat /tmp/schema_output.txt
                echo '```'
              else
                echo "#### ‚úÖ Schema Validation: Passed"
              fi
            } > /tmp/validation_comment.txt

            ISSUE_NUMBER=${{ github.event.issue.number }}
            echo "DEBUG: Commenting on issue $ISSUE_NUMBER"
            gh issue comment "$ISSUE_NUMBER" --body-file /tmp/validation_comment.txt
            gh label create "lint-fail" --color D73A4A --description "YAML linting or schema validation failed" || true
            gh issue edit "$ISSUE_NUMBER" --add-label "lint-fail"

            echo "Validation errors found. Exiting workflow."
            exit 1
          else
            echo "YAML linting and schema validation both passed."
            exit 0
          fi

      - name: Parse and validate request yaml
        id: issue_yaml
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Start Fraiche
          rm -f /tmp/issue.yaml /tmp/thirdparty_validator.yaml xx*

          # Extract YAML between codefence blocks
          jq -r '.issue.body' "$GITHUB_EVENT_PATH" | awk '/^```yaml/{flag=1; next} /^```/{flag=0} flag' > /tmp/issue.yaml
          jq -r '.issue.body' "$GITHUB_EVENT_PATH" | awk '/^```yaml/{flag=1; next} /^```/{flag=0} flag' > /tmp/thirdparty_validator.yaml
          
          # Splitting multi-line files for future updates (doesn't work now)
          csplit -z /tmp/issue.yaml '/---/' '{*}'
          FILES=$(ls xx* | tr '\n' ' ')
          echo "split_files=$FILES" >> $GITHUB_OUTPUT

          # Generate policy mappings if existing policy exists
          MAPPING=""
          for FILE in $FILES; do
            SERVICE_TYPE=$(yq '.security_group.serviceType' "$FILE")
            REGION=$(yq '.security_group.region' "$FILE" | tr '[:upper:]' '[:lower:]')
            if [ "$SERVICE_TYPE" = "privatelink-consumer" ]; then
              THIRD_NAME=$(yq '.security_group.thirdpartyName' "$FILE" | tr '[:upper:]' '[:lower:]')
              THIRD_ID=$(yq '.security_group.thirdPartyID' "$FILE")
              SERVICE=$(yq '.security_group.serviceName' "$FILE" | sed -E 's/.*vpce-svc/vpce-svc/' | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]-')
              FILENAME="${THIRD_NAME}-${THIRD_ID}-${SERVICE}-${REGION}-policy.yaml"
            else
              APPID=$(yq '.security_group.internalAppID' "$FILE" | tr '[:upper:]' '[:lower:]')
              SERVICENAME=$(yq '.security_group.serviceName' "$FILE" | tr '[:upper:]' '[:lower:]')
              FILENAME="${APPID}-${SERVICENAME}-${REGION}-policy.yaml"
            fi
            POLICY_PATH="infrastructure/policies/$FILENAME"   # <--- ADD THIS LINE!
            MAPPING="${MAPPING}${FILE},${POLICY_PATH}|"
            echo "[$FILE] ‚Üí [$FILENAME] ‚Üí exists? $( [ -f "$POLICY_PATH" ] && echo yes || echo no )"
          done
          MAPPING="${MAPPING%|}"
          echo "request_existing_mapping=$MAPPING" >> $GITHUB_OUTPUT

          echo "DEBUG: Mapping string: $MAPPING"
          echo "DEBUG: FILES list: $FILES"
          for f in $FILES; do
            echo "----- $f -----"
            cat $f
          done

          # Ensure serviceType label exists and is applied
          SERVICE_TYPE=$(yq '.security_group.serviceType' /tmp/issue.yaml | tr -d '"')
          
          # Make sure label exists, if not create
          gh label create "privatelink-consumer" --color 70EC23 --description "Request for privatelink-consumer" --force || true
          gh label create "privatelink-provider" --color 411DAB --description "Request for privatelink-provider" --force || true
          
          # Clean issue labels and re-add if changed
          gh issue edit ${{ github.event.issue.number }} --remove-label "privatelink-consumer" --remove-label "privatelink-provider" || true
          gh issue edit ${{ github.event.issue.number }} --add-label "$SERVICE_TYPE"

      - name: Set Issue YAML Outputs
        id: yaml_outputs
        if: "contains(github.event.issue.labels.*.name, 'skip-form-processing')"
        run: |
          # Determine request type from labels
          if [ "$(grep -c 'privatelink-consumer' <<< "${{ join(github.event.issue.labels.*.name, '\n') }}")" -gt 0 ]; then
            echo "request_type=consumer" >> $GITHUB_OUTPUT
            echo "schema_file=privatelink-consumer-schema.json" >> $GITHUB_OUTPUT
          elif [ "$(grep -c 'privatelink-provider' <<< "${{ join(github.event.issue.labels.*.name, '\n') }}")" -gt 0 ]; then
            echo "request_type=provider" >> $GITHUB_OUTPUT
            echo "schema_file=privatelink-provider-schema.json" >> $GITHUB_OUTPUT
          fi
          
          # Set other issue details
          echo "issue_number=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT
          echo "issue_author=${{ github.event.issue.user.login }}" >> $GITHUB_OUTPUT
          echo "issue_title=${{ github.event.issue.title }}" >> $GITHUB_OUTPUT
            
      - name: Log target (existing) file(s) if they exist
        run: |
          MAPPING="${{ steps.issue_yaml.outputs.request_existing_mapping }}"
          IFS='|' read -ra mappings <<< "$MAPPING"
          for map in "${mappings[@]}"; do
            IFS=',' read -r src dest <<< "$map"
            if [ -f "$dest" ]; then
              echo "=== EXISTING ($dest) ==="
              cat "$dest"
            else
              echo "=== EXISTING ($dest) DOES NOT EXIST ==="
            fi
          done

      - name: Duplicate Validation
        uses: drewpypro/drewpy-actions/yaml-duplicate-validator@v1
        id: duplicate_validation
        with:
          created_yaml: ${{ steps.issue_yaml.outputs.split_files }}
          request_existing_mapping: ${{ steps.issue_yaml.outputs.request_existing_mapping }}

      - name: Log duplicate validator output
        run: |
          echo "=== DUPLICATE VALIDATION OUTPUT ==="
          cat dupe_output.txt || echo "(No dupe_output.txt produced)"

      - name: Comment on issue if dupes are found
        if: ${{ steps.duplicate_validation.outputs.duplicates_detected == 'true' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh label create "dupe-detected" --color B60205 --description "Duplicate detected by automation" || true
          gh label create "needs-fix" --color FBCA04 --description "Issue needs correction" || true
          gh issue edit ${{ github.event.issue.number }} --add-label "needs-fix" --add-label "dupe-detected"
          gh issue comment ${{ github.event.issue.number }} --body-file dupe_output.txt
          echo "Duplicate(s) found, failing pipeline."
          exit 1

      - name: Third-Party Validation
        id: thirdparty_validation
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}          
        run: |
          pip install --quiet PyYAML
          chmod +x ./scripts/validate_thirdparty.py

          echo "üîç Validating third-party contract and risk..."
          python3 ./scripts/validate_thirdparty.py /tmp/thirdparty_validator.yaml ./thirdpartyDB.json > /tmp/thirdparty_validation.txt 2>&1 || (
            echo '### ‚ùå Third-party validation failed' > /tmp/comment.txt
            cat /tmp/thirdparty_validation.txt >> /tmp/comment.txt
            ISSUE_NUMBER=$(jq -r '.issue.number' "$GITHUB_EVENT_PATH")
            gh issue comment "$ISSUE_NUMBER" --body-file /tmp/comment.txt
            exit 1
          )

      # - name: AI Review
      #   env:
      #     DREWPYAI_API_KEY: ${{ secrets.DREWPYAI_API_KEY }}
      #     DREWPY_PAT: ${{ secrets.DREWPY_PAT }}
      #     ISSUE_BODY: ${{ github.event.issue.body }}
      #     GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      #   run: |
      #     echo "ü§ñ Cloning AI reviewer..."
      #     git clone https://x-access-token:${{ secrets.DREWPY_PAT }}@github.com/drewpypro/drewpy-ai-actions.git
      #     pip install -r drewpy-ai-actions/aws-netsec-automation-review/requirements.txt

      #     echo "üìä Running AI rule reviewer..."
      #     python3 drewpy-ai-actions/aws-netsec-automation-review/ai-rule-review.py \
      #       --input-file /tmp/issue.yaml \
      #       --output-file /tmp/ai_review_output.md || true

      #     echo "üìù Posting AI review result..."
      #     ISSUE_NUMBER=$(jq -r '.issue.number' "$GITHUB_EVENT_PATH")
      #     gh issue comment "$ISSUE_NUMBER" --body-file /tmp/ai_review_output.md

      # Commit Changes and Create PR (Always Runs)
      - name: Commit Changes and Create PR
        id: create_pr
        env:
          GH_TOKEN: ${{ secrets.PAT_GITHUB_ACTIONS }}
        run: |

          sudo wget -O /usr/local/bin/yq "https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64"
          sudo chmod +x /usr/local/bin/yq
          yq --version
        
          ISSUE_ID=${{ github.event.issue.number }}
          BRANCH="issue-${ISSUE_ID}"
          LABEL=$(jq -r '.issue.labels[0].name' "$GITHUB_EVENT_PATH")
          SERVICE_TYPE=$(yq '.security_group.serviceType' /tmp/issue.yaml | tr -d '"')
          AUTHOR=$(jq -r '.issue.user.login' "$GITHUB_EVENT_PATH")

          git config user.name "github-actions"
          git config user.email "github-actions@github.com"

          # Check if branch already exists
          if git ls-remote --heads origin | grep -q "refs/heads/$BRANCH"; then
            # Branch exists, create a unique branch name
            BRANCH="issue-${ISSUE_ID}-$(date +%s)"
          fi

          # Create and switch to the branch
          git checkout -b "$BRANCH"

          # MAPPING is src,dest|src2,dest2|... (from earlier pipeline step)
          MAPPING="${{ steps.issue_yaml.outputs.request_existing_mapping }}"
          IFS='|' read -ra mappings <<< "$MAPPING"
          for map in "${mappings[@]}"; do
            IFS=',' read -r src dest <<< "$map"
            if [ -f "$dest" ]; then
              yq -i '.rules += (load("'"$src"'").rules // [])' "$dest"
            else
              cp "$src" "$dest"
            fi
            git add "$dest"
          done

          # Commit only if there are changes
          if ! git diff --staged --quiet; then
            git commit -m "Add network access policies from issue #${ISSUE_ID}"
            
            # Force push or push with lease to handle potential conflicts
            git push -f origin "$BRANCH"

            PR_URL=$(gh pr create \
              --title "[Auto] Add network access policies from issue #${ISSUE_ID}" \
              --label "$SERVICE_TYPE" \
              --body "This PR adds multiple network access policies from issue #${ISSUE_ID}." \
              --head "$BRANCH" \
              --base main)

            echo "üîç PR created at $PR_URL"
            echo "author=$AUTHOR" >> "$GITHUB_OUTPUT"
            echo "üîé Detected issue author: $AUTHOR"
            
            if [ "$AUTHOR" = "blahsadfawerwa3r23rwerwe" ]; then
              echo "‚úÖ Auto-approving PR since author is $AUTHOR"
              gh pr merge "$PR_URL" --merge --delete-branch
              gh pr comment "$PR_URL" --body "‚úÖ Auto-merged since this request was submitted by @$AUTHOR"
            else
              echo "‚ÑπÔ∏è PR created but not auto-approved. Submitted by @$AUTHOR"
            fi
          else
            echo "No changes to commit"
          fi

      - name: Remove needs-fix and dupe-detected labels (if present)
        if: ${{ success() }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue edit ${{ github.event.issue.number }} --remove-label "needs-fix" --remove-label "dupe-detected"  || true
